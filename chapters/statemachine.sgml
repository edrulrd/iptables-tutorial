 <chapter id="statemachine">
  <title id="statemachine.title">The state machine</title>
  <indexterm zone="statemachine">
    <primary>State machine</primary>
  </indexterm>
  <indexterm zone="statemachine">
    <primary>State match</primary>
  </indexterm>
  <indexterm zone="statemachine">
    <primary>Conntrack</primary>
  </indexterm>
 
  <para>
  This chapter will deal with the state machine and explain it in
detail. After reading through it, you should have a complete understanding of
how the State machine works. We will also go through a large set of examples on
how states are dealt with within the state machine itself. These should clarify
everything in practice. </para>

  <section id="statemachineintroduction">
   <title id="statemachineintroduction.title">Introduction</title>
   <indexterm zone="statemachineintroduction">
     <primary>Basics</primary>
     <secondary>State machine</secondary>
   </indexterm>
  <indexterm zone="statemachineintroduction">
    <primary>State match</primary>
    <secondary>ESTABLISHED</secondary>
  </indexterm>
  <indexterm zone="statemachineintroduction">
    <primary>State match</primary>
    <secondary>NEW</secondary>
  </indexterm>
  <indexterm zone="statemachineintroduction">
    <primary>State match</primary>
    <secondary>RELATED</secondary>
  </indexterm>
  <indexterm zone="statemachineintroduction">
    <primary>State match</primary>
    <secondary>INVALID</secondary>
  </indexterm>

   <para>
  The state machine is a special part within iptables that should really not
be called the state machine at all, since it is really a connection tracking
machine. However, most people recognize it under the first name. Throughout
this chapter I will use these names more or less as if they were synonymous.
This should not be overly confusing. Connection tracking is done to let the
Netfilter framework know the state of a specific connection. Firewalls that
implement this are generally called stateful firewalls. A stateful firewall is
generally much more secure than non-stateful firewalls since it allows us to
write much tighter rule-sets.
   </para>

   <para> Within iptables, packets can be related to tracked connections
in four different so called states. These are known as
<command>NEW</command>, <command>ESTABLISHED</command>,
<command>RELATED</command> and <command>INVALID</command>. We will discuss
each of these in more depth later. With the <command>--state</command>
match we can easily control who or what is allowed to initiate new
sessions.
   </para>

   <para>
All of the connection tracking is done by special framework within the kernel
called conntrack. conntrack may be loaded either as a module, or as an
internal part of the kernel itself. Most of the time, we need and want more
specific connection tracking than the default conntrack engine can maintain.
Because of this, there are also more specific parts of conntrack that handles
the <systemitem>TCP</systemitem>, <systemitem>UDP</systemitem> or
<systemitem>ICMP</systemitem> protocols among others. These modules grab
specific, unique, information from the packets, so that they may keep track of
each stream of data. The information that conntrack gathers is then used to
tell conntrack in which state the stream is currently in. For example,
<systemitem>UDP</systemitem> streams are, generally, uniquely identified by
their <systemitem>destination IP address</systemitem>, <systemitem>source IP
address</systemitem>, <systemitem>destination port</systemitem> and
<systemitem>source port</systemitem>.
   </para>

   <para>
In previous kernels, we had the possibility to turn on and off
defragmentation. However, since iptables and Netfilter were introduced
and connection tracking in particular, this option was gotten rid of. The
reason for this is that connection tracking can not work properly without
defragmenting packets, and hence defragmenting has been incorporated into
conntrack and is carried out automatically. It can not be turned off,
except by turning off connection tracking. Defragmentation is always carried
out if connection tracking is turned on.
   </para>

   <para>
All connection tracking is handled in the <systemitem>PREROUTING</systemitem>
chain, except locally generated packets which are handled in the
<systemitem>OUTPUT</systemitem> chain. What this means is that iptables will
do all recalculation of states and so on within the
<systemitem>PREROUTING</systemitem> chain. If we send the initial packet in a
stream, the state gets set to <command>NEW</command> within the
<systemitem>OUTPUT</systemitem> chain, and when we receive a return packet,
the state gets changed in the <systemitem>PREROUTING</systemitem> chain to
<command>ESTABLISHED</command>, and so on. If the first packet is not
originated by ourself, the NEW state is set within the
<systemitem>PREROUTING</systemitem> chain of course. So, all state changes and
calculations are done within the <systemitem>PREROUTING</systemitem> and
<systemitem>OUTPUT</systemitem> chains of the nat table.
   </para>

   </section>

   <section id="theconntrackentries">
    <title id="theconntrackentries.title">The conntrack entries</title>
    <indexterm zone="theconntrackentries">
      <primary>Conntrack</primary>
      <secondary>Entries</secondary>
    </indexterm>
    <indexterm zone="theconntrackentries">
      <primary>Conntrack</primary>
      <secondary>ip_conntrack</secondary>
    </indexterm>
    <indexterm zone="theconntrackentries">
      <primary>Files</primary>
      <secondary>ip_conntrack</secondary>
    </indexterm>
    <indexterm zone="theconntrackentries">
      <primary>Ip_conntrack</primary>
    </indexterm>
    <indexterm zone="theconntrackentries">
      <primary>SYN_SENT</primary>
    </indexterm>
    <indexterm zone="theconntrackentries">
      <primary>ASSURED</primary>
    </indexterm>

    <para>
   Let's take a brief look at a conntrack entry and how to read them in
<filename>/proc/net/ip_conntrack</filename>. This gives a list of all the
current entries in your conntrack database. If you have the
<systemitem>ip_conntrack</systemitem> module loaded, a <command>cat</command>
of <filename>/proc/net/ip_conntrack</filename> might look like:
    </para>

     <screen>
tcp      6 117 SYN_SENT src=192.168.1.6 dst=192.168.1.9 sport=32775 \
     dport=22 [UNREPLIED] src=192.168.1.9 dst=192.168.1.6 sport=22 \
     dport=32775 [ASSURED] use=2
     </screen>

    <para>
   This example contains all the information that the conntrack module
maintains to know which state a specific connection is in. First of all, we
have a protocol, which in this case is tcp. Next, the same value
in normal decimal coding. After this, we see how long this conntrack entry has
to live. This value is set to 117 seconds right now and is decremented
regularly until we see more traffic. This value is then reset to the default
value for the specific state that it is in at that relevant point of time.
Next comes the actual state that this entry is in at the present point of
time. In the above mentioned case we are looking at a packet that is in the
<computeroutput>SYN_SENT</computeroutput> state. The internal value of a
connection is slightly different from the ones used externally with
<command>iptables</commanD>. The
value <computeroutput>SYN_SENT</computeroutput> tells us that we are looking
at a connection that has only seen a <systemitem>TCP SYN</systemitem> packet
in one direction. Next, we see the <systemitem>source IP
address</systemitem>, <systemitem>destination IP address</systemitem>,
<systemitem>source port</systemitem> and <systemitem>destination
port</systemitem>. At this point we see a specific keyword that tells us that
we have seen no return traffic for this connection. Lastly, we
see what we expect of return packets. The information details the
<systemitem>source IP address</systemitem> and <systemitem>destination IP
address</systemitem> (which are both inverted, since the packet is
to be directed back to us). The same thing goes for the
<systemitem>source port</systemitem> and <systemitem>destination
port</systemitem> of the connection. These are the values that should be of
any interest to us.
    </para>

    <para>
   The connection tracking entries may take on a series of different values,
all specified in the conntrack headers available in
<filename>linux/include/netfilter-ipv4/ip_conntrack*.h</filename> files.
These values are dependent on which sub-protocol of
<systemitem>IP</systemitem> we use. <systemitem>TCP</systemitem>,
<systemitem>UDP</systemitem> or <systemitem>ICMP</systemitem> protocols
take specific default values as specified in
<filename>linux/include/netfilter-ipv4/ip_conntrack.h</filename>. We will
look closer at this when we look at each of the protocols; however, we
will not use them extensively through this chapter, since they are not used
outside of the conntrack internals. Also, depending on how this state
changes, the default value of the time until the connection is destroyed
will also change.
    </para>

    <note>
     <para>
Recently there was a new patch made available in iptables patch-o-matic,
called tcp-window-tracking. This patch adds, among other things, all of
the above timeouts to special sysctl variables, which means that they can
be changed on the fly, while the system is still running. Hence, this
makes it unnecessary to recompile the kernel every time you want to change
the timeouts.
     </para>

     <para>
 These can be altered via using specific system calls available in the
<filename>/proc/sys/net/ipv4/netfilter</filename> directory. You should
in particular look at the
<filename>/proc/sys/net/ipv4/netfilter/ip_ct_*</filename> variables.
     </para>
    </note>

    <para>
   When a connection has seen traffic in both directions, the conntrack entry
will erase the <computeroutput>[UNREPLIED]</computeroutput> flag, and then
reset it. The entry that tells us that the connection has not seen any
traffic in both directions, will be replaced by the
<computeroutput>[ASSURED]</computeroutput> flag, to be found close to the end
of the entry. The <computeroutput>[ASSURED]</computeroutput> flag tells us
that this connection is assured and that it will not be erased if we reach the
maximum possible tracked connections. Thus, connections marked as
<computeroutput>[ASSURED]</computeroutput> will not be erased, contrary to
the non-assured connections (those not marked as
<computeroutput>[ASSURED]</computeroutput>). How many connections that the
connection tracking table can hold depends upon a variable that can be set
through the ip-sysctl functions in recent kernels. The default value held by
this entry varies heavily depending on how much memory you have. On 128 MB of
RAM you will get 8192 possible entries, and at 256 MB of RAM, you will get
16376 entries. You can read and set your settings through the
<filename>/proc/sys/net/ipv4/ip_conntrack_max</filename> setting.
    </para>
    
    <indexterm zone="theconntrackentries.conntrack.max">
      <primary>Files</primary>
      <secondary>ip_conntrack_max</secondary>
    </indexterm>
    <indexterm zone="theconntrackentries.conntrack.max">
      <primary>ip_conntrack_max</primary>
    </indexterm>
    <para id="theconntrackentries.conntrack.max">
A different way of doing this, that is more efficient, is to set the hashsize 
option to the <filename>ip_conntrack</filename> module once this is loaded. 
Under normal circumstances ip_conntrack_max equals 8 * hashsize. In other 
words, setting the hashsize to 4096 will result in ip_conntrack_max being set 
to 32768 conntrack entries. An example of this would be:
    </para>
    
      <screen>
<prompt>work3:/home/blueflux#</prompt> <userinput>modprobe ip_conntrack hashsize=4096</userinput>
<prompt>work3:/home/blueflux#</prompt> <userinput>cat /proc/sys/net/ipv4/ip_conntrack_max</userinput>
<computeroutput>32768</computeroutput>
<prompt>work3:/home/blueflux#</prompt>
      </screen>

    <note>
     <para>
With IPv6 now generally being an integral component of the operating system,
<filename>/proc/net/ip_conntrack</filename> has been replaced with
<filename>/proc/net/nf_conntrack</filename>.  The format is practically the same
except for the addition of 2 fields at the beginning of each record to indicate
the ip version used in the entry.
     </para>
     <para>
If installed, the <command>conntrack -L</command> command will also display the connection tracking list.
     </para>
     <para>
Also, instead of modifying entries in the
<filename>/proc/sys/net/ipv4/netfilter</filename> directory, the
<command>sysctl</command> command can be used for this purpose.
     </para>
    </note>

    </section>

    <section id="userlandstates">
     <title id="userlandstates.title">User-land states</title>
     <indexterm zone="userlandstates">
       <primary>User-land states</primary>
     </indexterm>
     <indexterm zone="userlandstates">
       <primary>State match</primary>
       <secondary>NEW</secondary>
     </indexterm>
     <indexterm zone="userlandstates">
       <primary>State match</primary>
       <secondary>ESTABLISHED</secondary>
     </indexterm>
     <indexterm zone="userlandstates">
       <primary>State match</primary>
       <secondary>RELATED</secondary>
     </indexterm>
     <indexterm zone="userlandstates">
       <primary>State match</primary>
       <secondary>INVALID</secondary>
     </indexterm>
     <indexterm zone="userlandstates">
       <primary>State match</primary>
       <secondary>UNTRACKED</secondary>
     </indexterm>

     <para>
     As you have seen, packets may take on several different states within the
kernel itself, depending on what protocol we are talking about. However,
outside the kernel, we only have the 4 states as described previously. These
states can mainly be used in conjunction with the state match which will then
be able to match packets based on their current connection tracking state. The
valid states are <command>NEW</command>,
<command>ESTABLISHED</command>, <command>RELATED</command> and
<command>INVALID</command>. The following table will briefly explain
each possible state.
     </para>

     <table id="table.userlandstates">
      <title id="table.userlandstates.title">User-land states</title>
      <tgroup cols=2 align=left colsep=1 rowsep=1>
      <colspec colwidth="72pt">
      <colspec colwidth="*">
       <thead>
        <row>
         <entry>State</entry>
         <entry>Explanation</entry>
        </row>
       </thead>
       <tbody>

       <row>
        <entry>NEW</entry>
        <entry>The <command>NEW</command> state tells us that the packet is
the first packet that we see. This means that the first packet that the
conntrack module sees, within a specific connection, will be matched. For
example, if we see a <systemitem>SYN</systemitem> packet and it is the first
packet in a connection that we see, it will match. However, the packet may as
well not be a <systemitem>SYN</systemitem> packet and still be considered
<command>NEW</command>. This may lead to certain problems in some instances,
but it may also be extremely helpful when we need to pick up lost connections
from other firewalls, or when a connection has already timed out, but in
reality is not closed.
        </entry>
       </row>

       <row>
        <entry>ESTABLISHED</entry>
        <entry>The <command>ESTABLISHED</command> state has seen traffic in both
directions and will then continuously match those packets.
<command>ESTABLISHED</command> connections are fairly easy to understand. The
only requirement to get into an <command>ESTABLISHED</command> state is that
one host sends a packet, and that it later on gets a reply from the other
host. The <command>NEW</command> state will upon receipt of the reply packet
to or through the firewall change to the <command>ESTABLISHED</command> state.
<systemitem>ICMP</systemitem> reply messages can also be
considered as <command>ESTABLISHED</command>, if we created a packet
that in turn generated the reply <systemitem>ICMP</systemitem> message.
        </entry>
       </row>

       <row>
        <entry>RELATED</entry>
        <entry>The <command>RELATED</command> state is one of the more tricky
states. A connection is considered <command>RELATED</command> when it is
related to another already <command>ESTABLISHED</command> connection. What
this means, is that for a connection to be considered as
<command>RELATED</command>, we must first have a connection that is considered
<command>ESTABLISHED</command>. The <command>ESTABLISHED</command> connection
will then spawn a connection outside of the main connection. The newly spawned
connection will then be considered <command>RELATED</command>, if the
conntrack module is able to understand that it is <command>RELATED</command>.
Some good examples of connections that can be considered as
<command>RELATED</command> are the <systemitem>FTP-data</systemitem>
connections that are considered <command>RELATED</command> to the
<systemitem>FTP control</systemitem> port, and the
<systemitem>DCC</systemitem> connections issued through
<systemitem>IRC</systemitem>. This could be used to allow
<systemitem>ICMP</systemitem> error messages, <systemitem>FTP</systemitem>
transfers and <systemitem>DCC</systemitem>'s to work properly through the
firewall. Do note that most <systemitem>TCP</systemitem> protocols and some
<systemitem>UDP</systemitem> protocols that rely on this mechanism are quite
complex and send connection information within the payload of the
<systemitem>TCP</systemitem> or <systemitem>UDP</systemitem> data segments,
and hence require special helper modules to be correctly understood. 
        </entry>
       </row>

       <row>
        <entry>INVALID</entry>
        <entry>The <command>INVALID</command> state means that the packet 
can't be identified or that it does not have any state. This may be due to
several reasons, such as the system running out of memory or
<systemitem>ICMP</systemitem> error messages that do not respond to any known
connections. Generally, it is a good idea to <command>DROP</command>
everything in this state.
        </entry>
       </row>

       <row>
        <entry>UNTRACKED</entry>
        <entry>This is the <command>UNTRACKED</command> state. In brief, if a 
packet is marked within the <systemitem>raw</systemitem> table with the 
<command>NOTRACK</command> target, then that packet will show up as 
<command>UNTRACKED</command> in the state machine. This also means that all 
<command>RELATED</command> connections will not be seen, so some caution must 
be taken when dealing with the <command>UNTRACKED</command> connections since 
the state machine will not be able to see related <systemitem>ICMP</systemitem> 
messages et cetera.
        </entry>
       </row>

       </tbody>
      </tgroup>
     </table>

     <para>
     These states can be used together with the <command>--state</command>
match to match packets based on their connection tracking state. This is what
makes the state machine so incredibly strong and efficient for our firewall.
Previously, we often had to open up all ports above 1024 to let all traffic
back into our local networks again. With the state machine in place this is
not necessary any longer, since we can now just open up the firewall for
return traffic and not for all kinds of other traffic.
     </para>

  </section>

  <section id="tcpconnections">
   <title id="tcpconnections.title">TCP connections</title>
   <indexterm zone="tcpconnections">
     <primary>TCP</primary>
   </indexterm>
   <indexterm zone="tcpconnections">
     <primary>State match</primary>
     <secondary>RELATED</secondary>
   </indexterm>
   <indexterm zone="tcpconnections">
     <primary>RFC</primary>
     <secondary>793</secondary>
   </indexterm>
   <indexterm zone="tcpconnections">
     <primary>TCP</primary>
     <secondary>Opening</secondary>
   </indexterm>
   <indexterm zone="tcpconnections">
     <primary>State match</primary>
     <secondary>TCP</secondary>
   </indexterm>

   <para>
In this section and the upcoming ones, we will take a closer look at the
states and how they are handled for each of the three basic protocols
<systemitem>TCP</systemitem>, <systemitem>UDP</systemitem> and
<systemitem>ICMP</systemitem>. Also, we will take a closer look at how
connections are handled per default, if they can not be classified as either
of these three protocols. We have chosen to start out with the
<systemitem>TCP</systemitem> protocol since it is a stateful protocol in
itself, and has a lot of interesting details with regard to the state machine
in iptables.
   </para>

   <para>
A <systemitem>TCP</systemitem> connection is always initiated with the 3-way
handshake, which establishes and negotiates the actual connection over which
data will be sent. The whole session is begun with a
<systemitem>SYN</systemitem> packet, then a <systemitem>SYN/ACK</systemitem>
packet and finally an <systemitem>ACK</systemitem> packet to acknowledge the
whole session establishment. At this point the connection is established and
able to start sending data. The big problem is, how does connection tracking
hook up into this? Quite simply really.
   </para>

   <para>
As  far  as the user is concerned, connection tracking works basically the
same for all connection types. Have a look at the picture
below to see exactly what state the stream enters during the different stages
of the connection. As you can see, the connection tracking code does not
really follow the flow of the <systemitem>TCP</systemitem> connection, from
the users viewpoint. Once it has seen one packet(the
<systemitem>SYN</systemitem>), it considers the connection as NEW. Once it
sees the return packet(<systemitem>SYN/ACK</systemitem>), it considers the
connection as <command>ESTABLISHED</command>. If you think about this a
second, you will understand why. With this particular implementation, you can
allow <command>NEW</command> and <command>ESTABLISHED</command> packets to
leave your local network, only allow <command>ESTABLISHED</command>
connections back, and that will work perfectly. Conversely, if the connection
tracking machine were to consider the whole connection establishment as
<command>NEW</command>, we would never really be able to stop outside
connections to our local network, since we would have to allow
<command>NEW</command> packets back in again. To make things more complicated,
there are a number of other internal states that are used for
<systemitem>TCP</systemitem> connections inside the kernel, but which are not
available for us in User-land. Roughly, they follow the state standards
specified within <link linkend="rfc793" endterm="rfc793.title"></link> on 
pages 21-23. We will consider these in more detail further along in this 
section.
   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-connecting.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-connecting.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
As you can see, it is really quite simple, seen from the user's point of view.
However, looking at the whole construction from the kernel's point of view,
it's a little more difficult. Let's look at an example. Consider exactly how
the connection states change in the
<filename>/proc/net/ip_conntrack</filename> table. The first state is reported
upon receipt of the first <systemitem>SYN</systemitem> packet in a connection.
   </para>

   <screen>
tcp      6 117 SYN_SENT src=192.168.1.5 dst=192.168.1.35 sport=1031 \
     dport=23 [UNREPLIED] src=192.168.1.35 dst=192.168.1.5 sport=23 \
     dport=1031 use=1
   </screen>

   <para>
As you can see from the above entry, we have a precise state in which a SYN
packet has been sent, (the <computeroutput>SYN_SENT</computeroutput>
flag is set), and to which as yet no reply has been sent (witness the
<computeroutput>[UNREPLIED]</computeroutput> flag). The next internal state
will be reached when we see another packet in the other direction.
   </para>

   <screen>
tcp      6 57 SYN_RECV src=192.168.1.5 dst=192.168.1.35 sport=1031 \
     dport=23 src=192.168.1.35 dst=192.168.1.5 sport=23 dport=1031 \
     use=1
   </screen>

   <para>
Now we have received a corresponding <systemitem>SYN/ACK</systemitem> in
return. As soon as this packet has been received, the state changes once
again, this time to <computeroutput>SYN_RECV</computeroutput>.
<indexterm><primary>SYN_RECV</primary></indexterm>
<computeroutput>SYN_RECV</computeroutput> tells us that the original
<systemitem>SYN</systemitem> was delivered correctly and that the
<systemitem>SYN/ACK</systemitem> return packet also got through the firewall
properly. Moreover, this connection tracking entry has now seen traffic in
both directions and is hence considered as having been replied to. This is not
explicit, but rather assumed, as was the
<computeroutput>[UNREPLIED]</computeroutput>
<indexterm><primary>[UNREPLIED]</primary></indexterm>
<indexterm><primary>UNREPLIED</primary></indexterm> flag above. The final
step will be reached once we have seen the final <systemitem>ACK</systemitem>
in the 3-way handshake.
   </para>

   <screen>
tcp      6 431999 ESTABLISHED src=192.168.1.5 dst=192.168.1.35 \
     sport=1031 dport=23 src=192.168.1.35 dst=192.168.1.5 \
     sport=23 dport=1031 [ASSURED] use=1
   </screen>

   <para>
In the last example, we have gotten the final <systemitem>ACK</systemitem> in
the 3-way handshake and the connection has entered the
<command>ESTABLISHED</command> state, as far as the internal mechanisms of
iptables are aware. Normally, the stream will be 
<computeroutput>ASSURED</computeroutput>
<indexterm><primary>ASSURED</primary></indexterm> by now.
   </para>
   
   <para>
A connection may also enter the <command>ESTABLISHED</command> state, but not
be<computeroutput>[ASSURED]</computeroutput>.
<indexterm><primary>[ASSURED]</primary></indexterm> This happens if we have
connection pickup turned on (Requires the tcp-window-tracking patch, and the
ip_conntrack_tcp_loose
<indexterm><primary>ip_conntrack_tcp_loose</primary></indexterm>
<indexterm><primary>Files</primary>
<secondary>ip_conntrack_tcp_loose</secondary></indexterm> to be set to 1 or
higher). The default, without the tcp-window-tracking patch, is to have this
behaviour, and is not changeable.
   </para>

   <para>
When a <systemitem>TCP</systemitem> connection is closed down, it is done in
the following way and takes the following states.
   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-closing.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-closing.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
As you can see, the connection is never really closed until the last
<systemitem>ACK</systemitem> is sent. Do note that this picture only describes
how it is closed down under normal circumstances. A connection may also, for
example, be closed by sending a <systemitem>RST</systemitem>(reset), if
the connection were to be refused. In this case, the connection would be
closed down immediately.
   </para>

   <para>
When the <systemitem>TCP</systemitem> connection has been closed down, the
connection enters the <computeroutput>TIME_WAIT</computeroutput> state, which
is per default set to 2 minutes. This is used so that all packets that have
gotten out of order can still get through our rule-set, even after the
connection has already closed. This is used as a kind of buffer time so that
packets that have gotten stuck in one or another congested router can still
get to the firewall, or to the other end of the connection.
   </para>

   <para>
   If the connection is reset by a <systemitem>RST</systemitem> packet,
the state is changed to <computeroutput>CLOSE</computeroutput>. This
means that the connection per default has 10 seconds before the whole
connection is definitely closed down. <systemitem>RST</systemitem> packets are
not acknowledged in any sense, and will break the connection directly. There
are also other states than the ones we have told you about so far. Here is the
complete list of possible states that a <systemitem>TCP</systemitem> stream
may take, and their timeout values.
</para>

   <table id="table.internalstates">
    <title id="table.internalstates.title">Internal states</title>
    <tgroup cols=2 align=left colsep=1 rowsep=1>
    <colspec colwidth="2*">
    <colspec colwidth="5*">
     <thead>
      <row>
       <entry>State</entry>
       <entry>Timeout value</entry>
      </row>
     </thead>
     <tbody>

     <row>
      <entry>NONE</entry>
      <entry>30 minutes</entry>
     </row>
     <row>
      <entry>ESTABLISHED</entry>
      <entry>5 days</entry>
     </row>
     <row>
      <entry>SYN_SENT</entry>
      <entry>2 minutes</entry>
     </row>
     <row>
      <entry>SYN_RECV</entry>
      <entry>60 seconds</entry>
     </row>
     <row>
      <entry>FIN_WAIT</entry>
      <entry>2 minutes</entry>
     </row>
     <row>
      <entry>TIME_WAIT</entry>
      <entry>2 minutes</entry>
     </row>
     <row>
      <entry>CLOSE</entry>
      <entry>10 seconds</entry>
     </row>
     <row>
      <entry>CLOSE_WAIT</entry>
      <entry>12 hours</entry>
     </row>
     <row>
      <entry>LAST_ACK</entry>
      <entry>30 seconds</entry>
     </row>
     <row>
      <entry>LISTEN</entry>
      <entry>2 minutes</entry>
     </row>

     </tbody>
    </tgroup>
   </table>

   <para>
   These values are most definitely not absolute. They may change with kernel
revisions, and they may also be changed via the proc file-system in the
<filename>/proc/sys/net/ipv4/netfilter/ip_ct_tcp_*</filename> variables. The
default values should, however, be fairly well established in practice. These
values are set in seconds. Early versions of the patch used jiffies (which 
was a bug).
   </para>

    <note>
     <para>
As noted above, the connection tracking status for systems that include IPv6
is in <filename>/proc/net/nf_conntrack</filename>.  You can also see connection tracking
state with the <command>conntrack -L</command>.
To see the timeout settings for your system, see the
net.netfilter.nf_conntrack_tcp_timeout_* values
displayed when <command>sysctl -a</command> is run.
     </para>
    </note>
   <note>
    <para>
Also note that the User-land side of the state machine does not look at 
<systemitem>TCP</systemitem> flags (i.e., RST, ACK, and SYN are flags) set in 
the <systemitem>TCP</systemitem> packets. This is generally bad, since you may 
want to allow packets in the <command>NEW</command> state to get through the 
firewall, but when you specify the <command>NEW</command> flag, you will in 
most cases mean <systemitem>SYN</systemitem> packets.
    </para>

    <para>
This is not what happens with the current state implementation; instead, even a
packet with no bit set or an <systemitem>ACK</systemitem> flag, will count as
<command>NEW</command>.
This can be used for redundant firewalling and so on, but it is generally
extremely bad on your home network, where you only have a single firewall. To
get around this behavior, you could use the command explained in the <link
linkend="newnotsyn" endterm="newnotsyn.title"></link> section of the <link
linkend="commonproblems" endterm="commonproblems.title"></link> appendix.
Another way is to install the <command>tcp-window-tracking</command> extension
from <command>patch-o-matic</command>, and set the 
<filename>/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_loose</filename> to 
zero, which will make the firewall drop all NEW packets with anything but the 
<systemitem>SYN</systemitem> flag set.
    </para>
   </note>

  </section>

  <section id="udpconnections">
   <title id="udpconnections.title">UDP connections</title>
   <indexterm zone="udpconnections">
     <primary>UDP</primary>
   </indexterm>
   <indexterm zone="udpconnections">
     <primary>State match</primary>
     <secondary>[UNREPLIED]</secondary>
   </indexterm>
   <indexterm zone="udpconnections">
     <primary>State match</primary>
     <secondary>UDP</secondary>
   </indexterm>
   <indexterm zone="udpconnections">
     <primary>State match</primary>
     <secondary>[ASSURED]</secondary>
   </indexterm>

   <para>
<systemitem>UDP</systemitem> connections are in themselves not stateful
connections, but rather stateless. There are several reasons why, mainly
because they don't contain any connection establishment or connection
closing; most of all they lack sequencing. Receiving two
<systemitem>UDP</systemitem> datagrams in a specific order does not say
anything about the order in which they were sent. It is, however,
still possible to set states on the connections within the kernel. Let's have
a look at how a connection can be tracked and how it might look in conntrack.

   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-udp-connection.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-udp-connection.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
As you can see, the connection is brought up almost exactly in the
same way as a <systemitem>TCP</systemitem> connection. That is, from the
user-land point of view. Internally, conntrack information looks quite a bit
different, but intrinsically the details are the same. First of all, let's
have a look at the entry after the initial <systemitem>UDP</systemitem> packet
has been sent.
   </para>

   <screen>
udp      17 20 src=192.168.1.2 dst=192.168.1.5 sport=137 dport=1025 \
     [UNREPLIED] src=192.168.1.5 dst=192.168.1.2 sport=1025 \
     dport=137 use=1
   </screen>

   <para>
As you can see from the first and second values, this is an
<systemitem>UDP</systemitem> packet. The
first is the protocol name, and the second is protocol number. This is just
the same as for <systemitem>TCP</systemitem> connections. The third value
marks how many seconds this state entry has to live. After this, we get the
values of the packet that we have seen and the future expectations of packets
over this connection reaching us from the initiating packet sender. These are
the source, destination, source port and destination port. At this
point, the <computeroutput>[UNREPLIED]</computeroutput> flag tells us that
there's so far been no response to the packet. Finally, we get a brief list of
the expectations for returning packets. Do note that the latter entries are
in reverse order to the first values. The timeout at this
point is set to 30 seconds, as per default.

   </para>

   <screen>
udp      17 170 src=192.168.1.2 dst=192.168.1.5 sport=137 \
     dport=1025 src=192.168.1.5 dst=192.168.1.2 sport=1025 \
     dport=137 [ASSURED] use=1
   </screen>

   <para>
At this point the server has seen a reply to the first packet sent out and the
connection is now considered as <command>ESTABLISHED</command>. This is not
shown in the connection tracking, as you can see. The main difference is that
the <computeroutput>[UNREPLIED]</computeroutput> flag has now gone. Moreover,
the default timeout has changed to 180 seconds - but in this example that's
by now been decremented to 170 seconds - in 10 seconds' time, it will be 160
seconds. There's one thing that's missing, though, and can change a bit, and
that is the <computeroutput>[ASSURED]</computeroutput> flag described above.
For the <computeroutput>[ASSURED]</computeroutput> flag to be set on a tracked
connection, there must have been a legitimate reply packet to the NEW packet.

   </para>

   <screen>
udp      17 175 src=192.168.1.5 dst=195.22.79.2 sport=1025 \
     dport=53 src=195.22.79.2 dst=192.168.1.5 sport=53 \
     dport=1025 [ASSURED] use=1
   </screen>

   <para>
At this point, the connection has become assured. The connection looks
exactly the same as the previous example. If this connection is not
used for 180 seconds, it times out. 180 Seconds is a comparatively low value,
but should be sufficient for most use. This value is reset to its full value
for each packet that matches the same entry and passes through the firewall,
just the same as for all of the internal states.
   </para>

  </section>

  <section id="icmpconnections">
   <title id="icmpconnections.title">ICMP connections</title>
   <indexterm zone="icmpconnections">
     <primary>ICMP</primary>
   </indexterm>
   <indexterm zone="icmpconnections">
     <primary>State match</primary>
     <secondary>ICMP</secondary>
   </indexterm>
   <indexterm zone="icmpconnections">
     <primary>State match</primary>
     <secondary>ESTABLISHED</secondary>
   </indexterm>
   <indexterm zone="icmpconnections">
     <primary>State match</primary>
     <secondary>NEW</secondary>
   </indexterm>

   <para>
<systemitem>ICMP</systemitem> packets are far from a stateful stream, since
they are only used for controlling and should never establish any connections.
There are four <systemitem>ICMP</systemitem> types that will generate return
packets however, and these have 2 different states. These
<systemitem>ICMP</systemitem> messages can take the <command>NEW</command> and
<command>ESTABLISHED</command> states. The <systemitem>ICMP</systemitem> types
we are talking about are <systemitem>Echo request</systemitem> and
<systemitem>reply</systemitem>, <systemitem>Timestamp request</systemitem> and
<systemitem>reply</systemitem>, <systemitem>Information request</systemitem>
and <systemitem>reply</systemitem> and finally <systemitem>Address mask
request</systemitem> and <systemitem>reply</systemitem>. Out of these, the
<systemitem>timestamp request</systemitem> and <systemitem>information
request</systemitem> are obsolete and could most probably just be dropped.
However, the <systemitem>Echo</systemitem> messages are used in several setups
such as pinging hosts. <systemitem>Address mask requests</systemitem> are not
used often, but could be useful at times and worth allowing. To get
an idea of how this could look, have a look at the following image.
   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-icmp-ping.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-icmp-ping.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
As you can see in the above picture, the host sends an <systemitem>echo
request</systemitem> to the target, which is considered as
<command>NEW</command> by the firewall. The target then responds with a
<systemitem>echo reply</systemitem> which the firewall considers as state
<command>ESTABLISHED</command>. When the first echo request has been seen, the
following state entry goes into the <filename>ip_conntrack</filename>.
   </para>

   <screen>
icmp     1 25 src=192.168.1.6 dst=192.168.1.10 type=8 code=0 \
     id=33029 [UNREPLIED] src=192.168.1.10 dst=192.168.1.6 \
     type=0 code=0 id=33029 use=1
   </screen>

   <para>
This entry looks a little bit different from the standard states for
<systemitem>TCP</systemitem> and <systemitem>UDP</systemitem> as you can see.
The protocol is there, and the timeout, as well as source and destination
addresses. The problem comes after that however. We now have 3 new fields
called <computeroutput>type</computeroutput>,
<computeroutput>code</computeroutput> and <computeroutput>id</computeroutput>.
They are not special in any way, the <computeroutput>type</computeroutput>
field contains the <systemitem>ICMP</systemitem> type and the
<computeroutput>code</computeroutput> field contains the
<systemitem>ICMP</systemitem> code. These are all available in <link
linkend="icmptypes" endterm="icmptypes.title"></link> appendix. The final
<computeroutput>id</computeroutput> field, contains the <systemitem>ICMP
ID</systemitem>. Each <systemitem>ICMP</systemitem> packet gets an ID set to
it when it is sent, and when the receiver gets the
<systemitem>ICMP</systemitem> message, it sets the same
<systemitem>ID</systemitem> within the new <systemitem>ICMP</systemitem>
message so that the sender will recognize the reply and will be able to
connect it with the correct <systemitem>ICMP</systemitem> request.
   </para>

   <para>
The next field, we once again recognize as the
<computeroutput>[UNREPLIED]</computeroutput> flag, which we have seen before.
Just as before, this flag tells us that we are currently looking at a
connection tracking entry that has seen only traffic in one direction.
Finally, we see the reply expectation for the reply
<systemitem>ICMP</systemitem> packet, which is the inversion of the original
source and destination IP addresses. As for the type and code, these are
changed to the correct values for the return packet, so an echo request is
changed to echo reply and so on. The <systemitem>ICMP ID</systemitem> is
preserved from the request packet.
   </para>

   <para>
The reply packet is considered as being <command>ESTABLISHED</command>, as we
have already explained. However, we can know for sure that after the
<systemitem>ICMP</systemitem> reply, there will be absolutely no more legal
traffic in the same connection. For this reason, the connection tracking entry
is destroyed once the reply has traveled all the way through the Netfilter
structure.
   </para>

   <para>
In each of the above cases, the request is considered as
<command>NEW</command>, while the reply is considered as
<command>ESTABLISHED</command>. Let's consider this more closely. When the
firewall sees a request packet, it considers it as <command>NEW</command>.
When the host sends a reply packet to the request it is considered
<command>ESTABLISHED</command>.
   </para>

   <note>
    <para>
Note that this means that the reply packet must match the criterion given by
the connection tracking entry to be considered as established, just as with
all other traffic types.
    </para>
   </note>

   <para>
ICMP requests has a default timeout of 30 seconds, which you can change in the
<filename>/proc/sys/net/ipv4/netfilter/ip_ct_icmp_timeout</filename> entry.
This should in general be a good timeout value, since it will be able to catch
most packets in transit.  You may also be able to confirm this by checking the
value of the net.netfilter.nf_conntrack_icmp_timeout entry displayed from
running <command>sysctl -a</command>.

   </para>

   <para>
Another hugely important part of <systemitem>ICMP</systemitem> is the fact
that it is used to tell the hosts what happened to specific
<systemitem>UDP</systemitem> and <systemitem>TCP</systemitem> connections or
connection attempts. For this simple reason, ICMP replies will very often be
recognized as <command>RELATED</command> to original connections or
connection attempts. A simple example would be the
<systemitem>ICMP Host unreachable</systemitem> or <systemitem>ICMP Network
unreachable</systemitem>. These should always be spawned back to our host if
it attempts an unsuccessful connection to some other host, but the network or
host in question could be down, and hence the last router trying to reach the
site in question will reply with an <systemitem>ICMP</systemitem> message
telling us about it. In this case, the <systemitem>ICMP</systemitem> reply is
considered as a <command>RELATED</command> packet. The following picture
should explain how it would look.

   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-icmp-reply.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-icmp-reply.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
   In the above example, we send out a <systemitem>SYN</systemitem> packet to
a specific address. This is considered as a <command>NEW</command> connection
by the firewall. However, the network the packet is trying to reach is
unreachable, so a router returns a network unreachable
<systemitem>ICMP</systemitem> error to us. The connection tracking code can
recognize this packet as <command>RELATED</command>. thanks to the already
added tracking entry, so the <systemitem>ICMP</systemitem> reply is correctly
sent to the client which will then hopefully abort. Meanwhile, the firewall
has destroyed the connection tracking entry since it knows this was an error
message.
   </para>

   <para>
The same behavior as above is experienced with <systemitem>UDP</systemitem>
connections if they run into any problem like the above. All
<systemitem>ICMP</systemitem> messages sent in reply to
<systemitem>UDP</systemitem> connections are considered as
<command>RELATED</command>. Consider the following image.
   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-udp-icmp-reply.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-udp-icmp-reply.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
This time an <systemitem>UDP</systemitem> packet is sent to the host. This
<systemitem>UDP</systemitem> connection is considered as
<command>NEW</command>. However, the network is administratively prohibited by
some firewall or router on the way over. Hence, our firewall receives a
<systemitem>ICMP Network Prohibited</systemitem> in return. The firewall knows
that this <systemitem>ICMP</systemitem> error message is related to the
already opened <systemitem>UDP</systemitem> connection and sends it as a
<command>RELATED</command> packet to the client. At this point, the firewall
destroys the connection tracking entry, and the client receives the
<systemitem>ICMP</systemitem> message and should hopefully abort.

   </para>

  </section>

  <section id="defaultconnections">
   <title id="defaultconnections.title">Default connections</title>
   <indexterm zone="defaultconnections">
     <primary>State machine</primary>
     <secondary>Default connections</secondary>
   </indexterm>
   <indexterm zone="untrackedconns">
     <primary>File</primary>
     <secondary>ip_ct_generic_timeout</secondary>
   </indexterm>

   <para>
In certain cases, the conntrack machine does not know how to handle a specific
protocol. This happens if it does not know about that protocol in particular,
or doesn't know how it works. In these cases, it goes back to a default
behavior. The default behavior is used on, for example,
<systemitem>NETBLT</systemitem>, <systemitem>MUX</systemitem> and
<systemitem>EGP</systemitem>. This behavior looks pretty much the
same as the <systemitem>UDP</systemitem> connection tracking. The first packet
is considered <command>NEW</command>, and reply traffic and so forth is
considered <command>ESTABLISHED</command>.
   </para>

   <para>
When the default behavior is used, all of these packets will attain the same
default timeout value. This can be set via the
<filename>/proc/sys/net/ipv4/netfilter/ip_ct_generic_timeout</filename>
variable (or net.netfilter.nf_conntrack_generic_timeout variable as seen by running
<command>sysctl -a</command>). The default value here is 600 seconds, or 10 minutes. Depending
on
what traffic you are trying to send over a link that uses the default
connection tracking behavior, this might need changing. Especially if you are
bouncing traffic through satellites and such, which can take a long time.
   </para>

  </section>

  <section id="untrackedconns">
   <title id="untrackedconns.title">Untracked connections and the raw 
table</title>
   <indexterm zone="untrackedconns">
     <primary>State match</primary>
     <secondary>Untracked connections</secondary>
   </indexterm>
   <indexterm zone="untrackedconns">
     <primary>State match</primary>
     <secondary>NOTRACK</secondary>
     <seealso>NOTRACK target</seealso>
   </indexterm>
   <indexterm zone="untrackedconns">
     <primary>NOTRACK target</primary>
   </indexterm>

   <para>
<command>UNTRACKED</command> is a rather special keyword when it comes to 
connection tracking in Linux. Basically, it is used to match packets that has 
been marked in the <systemitem>raw</systemitem> table not to be tracked. 
   </para>

   <para>
The <systemitem>raw</systemitem> table was created specifically for this 
reason. In this table, you set a <command>NOTRACK</command> mark on packets 
that you do not wish to track in netfilter.
   </para>

   <important>
    <para>
Notice how I say packets, not connection, since the mark is actually set for 
each and every packet that enters. Otherwise, we would still have to do some 
kind of tracking of the connection to know that it should not be tracked. 
    </para>
   </important>

   <para>
As we have already stated in this chapter, <systemitem>conntrack</systemitem> 
and the state machine is rather resource hungry. For this reason, it might 
sometimes be a good idea to turn off connection tracking and the state machine. 
   </para>

   <para>
One example would be if you have a heavily trafficked router that you want to 
firewall the incoming and outgoing traffic on, but not the routed traffic. You 
could then set the <command>NOTRACK</command> mark on all packets not destined 
for the firewall itself by <command>ACCEPT</command>'ing all packets with 
destination your host in the <systemitem>raw</systemitem> table, and then set 
the <command>NOTRACK</command> for all other traffic. This would then allow 
you to have stateful matching on incoming traffic for the router itself, 
but at the same time save processing power from not handling all the crossing 
traffic.
   </para>

   <para>
Another example when <command>NOTRACK</command> can be used is if you have 
a highly trafficked webserver and want to do stateful tracking, but don't want 
to waste processing power on tracking the web traffic. You could then set up a 
rule that turns of tracking for port 80 on all the locally owned IP addresses, 
or the ones that are actually serving web traffic. You could then enjoy 
statefull tracking on all other services, except for webtraffic which might 
save some processing power on an already overloaded system.
   </para>

   <para>
There is however some problems with <command>NOTRACK</command> that you must 
take into consideration. If a whole connection is set with 
<command>NOTRACK</command>, then you will not be able to track related 
connections either, <systemitem>conntrack</systemitem> and 
<systemitem>nat</systemitem> helpers will simply not work for
<systemitem>untracked connections</systemitem>, nor will related 
<systemitem>ICMP</systemitem> errors do. You will have to open up for these 
manually in other words. When it comes to complex protocols such as 
<systemitem>FTP</systemitem> and <systemitem>SCTP</systemitem> et cetera, this 
can be very hard to manage. As long as you are aware of this, you should be 
able to handle this however.
   </para>
  </section>

  <section id="complexprotocols">
   <title id="complexprotocols.title">Complex protocols and connection tracking</title>
   <indexterm zone="complexprotocols">
     <primary>State match</primary>
     <secondary>Complex protocols</secondary>
     <seealso>Complex protocols</seealso>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>FTP</primary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>IRC</primary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>TFTP</primary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>Amanda</primary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>Complex protocols</primary>
     <secondary>FTP</secondary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>Complex protocols</primary>
     <secondary>IRC</secondary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>Complex protocols</primary>
     <secondary>TFTP</secondary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>Complex protocols</primary>
     <secondary>Amanda</secondary>
   </indexterm>
   <indexterm zone="complexprotocols">
     <primary>Conntrack</primary>
     <secondary>Helpers</secondary>
   </indexterm>

   <para> Certain protocols are more complex than others. What this means
when it comes to connection tracking, is that such protocols may be harder
to track correctly. Good examples of these are the
<systemitem>ICQ</systemitem>, <systemitem>IRC</systemitem> and
<systemitem>FTP</systemitem> protocols. Each and every one of these
protocols carries information within the actual data payload of the
packets, and hence requires special connection tracking helpers to enable
it to function correctly.
   </para>
   
   <para>
This is a list of the complex protocols that has support inside the linux 
kernel, and which kernel version it was introduced in.
   </para>

   <table frame=all id="table.complexprotocols">
    <title id="table.complexprotocols.title">Complex protocols support</title>
    <tgroup cols=2 align=left colsep=1 rowsep=1>
    <colspec colwidth="2*">
    <colspec colwidth="1*">
      <thead>
       <row>
        <entry>Protocol name</entry>
        <entry>Kernel versions</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>FTP</entry>
        <entry>2.3</entry>
       </row>
       <row>
        <entry>IRC</entry>
        <entry>2.3</entry>
       </row>
       <row>
        <entry>TFTP</entry>
        <entry>2.5</entry>
       </row>
       <row>
        <entry>Amanda</entry>
        <entry>2.5</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   
   <itemizedlist mark="opencircle">
    <listitem><para>FTP</para></listitem>
    <listitem><para>IRC</para></listitem>
    <listitem><para>TFTP</para></listitem>
   </itemizedlist>
   
   <para> Let's take the <systemitem>FTP</systemitem> protocol as the
first example. The <systemitem>FTP</systemitem> protocol first opens up a
single connection that is called the <systemitem>FTP control</systemitem>
session. When we issue commands through this session, other ports are
opened to carry the rest of the data related to that specific command.
These connections can be done in two ways, either actively or passively.
When a connection is done actively, the <systemitem>FTP</systemitem>
client sends the server a port and IP address to connect to. After this,
the <systemitem>FTP</systemitem> client opens up the port and the server
connects to that specified port from a random unprivileged port (>1024) 
and sends the data over it.
   </para>

   <para> The problem here is that the firewall will not know about these
extra connections, since they were negotiated within the actual payload
of the protocol data. Because of this, the firewall will be unable to know
that it should let the server connect to the client over these specific
ports.
   </para>

   <para> The solution to this problem is to add a special helper to the
connection tracking module which will scan through the data in the control
connection for specific syntaxes and information. When it runs into the
correct information, it will add that specific information as
<command>RELATED</command> and the server will be able to track the
connection, thanks to that <command>RELATED</command> entry. Consider the
following picture to understand the states when the
<systemitem>FTP</systemitem> server has made the connection back to the
client.
   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-server-subconn.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-server-subconn.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para>
<systemitem>Passive FTP</systemitem> works the opposite way. The
<systemitem>FTP</systemitem> client tells the server that it wants some
specific data, upon which the server replies with an IP address to connect to
and at what port. The client will, upon receipt of this data, connect to that
specific port, from its own port 20(the FTP-data port), and get the data in
question. If you have an <systemitem>FTP</systemitem> server behind your
firewall, you will in other words require this module in addition to your
standard iptables modules to let clients on the Internet connect to the
<systemitem>FTP</systemitem> server properly. The same goes if you are
extremely restrictive to your users, and only want to let them reach
<systemitem>HTTP</systemitem> and <systemitem>FTP</systemitem> servers on the
Internet and block all other ports. Consider the following image and its
bearing on Passive <systemitem>FTP</systemitem>.
   </para>

   <para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-client-subconn.eps" format=eps>
     </imageobject>
     <imageobject>
      <imagedata fileref="images/state-tcp-client-subconn.jpg" format=jpg>
     </imageobject>
    </mediaobject>
   </para>

   <para> Some conntrack helpers are already available within the kernel
itself. More specifically, the <systemitem>FTP</systemitem> and
<systemitem>IRC</systemitem> protocols have conntrack helpers as of
writing this. If you can not find the conntrack helpers that you need
within the kernel itself, you should have a look at the
<systemitem>patch-o-matic</systemitem> tree within user-land iptables. The
<systemitem>patch-o-matic</systemitem> tree may contain more conntrack
helpers, such as for the <systemitem>ntalk</systemitem> or
<systemitem>H.323</systemitem> protocols. If they are not available in the
patch-o-matic tree, you have a number of options. Either you can look at
the CVS source of iptables, if it has recently gone into that tree, or you
can contact the <link linkend="otherresources">Netfilter-devel</link>
mailing list and ask if it is available. If it is not, and there are no
plans for adding it, you are left to your own devices and would most
probably want to read the <link linkend="netfilterhackinghowto">Rusty
Russell's Unreliable Netfilter Hacking HOW-TO</link> which is linked from
the <link linkend="otherresources" endterm="otherresources.title"></link>
appendix.

   </para>

   <para>
Conntrack helpers may either be statically compiled into the kernel, or as
modules. If they are compiled as modules, you can load them with the following
command
   </para>

   <screen>
<command>
modprobe ip_conntrack_ftp
modprobe ip_conntrack_irc
modprobe ip_conntrack_tftp
modprobe ip_conntrack_amanda
</command>
   </screen>

   <para>
Do note that connection tracking has nothing to do with
<systemitem>NAT</systemitem>, and hence you may require more modules if you
are NAT'ing connections as well. For example, if you were to want to
<systemitem>NAT</systemitem> and track <systemitem>FTP</systemitem>
connections, you would need the <systemitem>NAT</systemitem> module as well.
All <systemitem>NAT</systemitem> helpers starts with ip_nat_ and follow that
naming convention; so for example the <systemitem>FTP</systemitem>
<systemitem>NAT</systemitem> helper would be named
<systemitem>ip_nat_ftp</systemitem> and the <systemitem>IRC</systemitem>
module would be named <systemitem>ip_nat_irc</systemitem>. The conntrack
helpers follow the same naming convention, and hence the
<systemitem>IRC</systemitem> conntrack helper would be named
<systemitem>ip_conntrack_irc</systemitem>, while the
<systemitem>FTP</systemitem> conntrack helper would be named
<systemitem>ip_conntrack_ftp</systemitem>.
   </para>
  </section>

  <section>
    <title>What's next?</title>

    <para>
This chapter has discussed how the state machine in netfilter works and how it
keeps state of different connections. The chapter has also discussed how it is
represented toward you, the end user and what you can do to alter its
behavior, as well as different protocols that are more complex to do
connection tracking on, and how the different conntrack helpers come into the
picture.
    </para>

    <para>
The next chapter will discuss how to save and restore rulesets using the
<command>iptables-save</command> and <command>iptables-restore</command>
programs distributed with the <command>iptables</command> applications. This
has both pros and cons, and the chapter will discuss it in detail.
    </para>
  </section>

 </chapter>
